We have a web server container running the nginx image. The access and error logs generated by the web server are not critical enough to be placed on a persistent volume. However, Nautilus developers need access to the last 24 hours of logs so that they can trace issues and bugs. Therefore, we need to ship the access and error logs for the web server to a log-aggregation service. Following the separation of concerns principle, we implement the Sidecar pattern by deploying a second container that ships the error and access logs from nginx. Nginx does one thing, and it does it well‚Äîserving web pages. The second container also specializes in its task‚Äîshipping logs. Since containers are running on the same Pod, we can use a shared emptyDir volume to read and write logs.


Create a pod named webserver.

Create an emptyDir volume shared-logs.

Create two containers from nginx and ubuntu images with latest tag only and remember to mention tag i.e nginx:latest, nginx container name should be nginx-container and ubuntu container name should be sidecar-container on webserver pod.

Add command on sidecar-container "sh","-c","while true; do cat /var/log/nginx/access.log /var/log/nginx/error.log; sleep 30; done"

Mount the volume shared-logs on both containers at location /var/log/nginx, all containers should be up and running.

Note: The kubectl utility on jump_host has been configured to work with the kubernetes cluster.

## Solution

You can achieve this by creating a **single Pod with two containers (Sidecar pattern)** sharing an **emptyDir** volume.

Below is the **complete Pod manifest** that satisfies all the requirements.

---

### ‚úÖ Pod Definition (webserver)

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: webserver
spec:
  volumes:
    - name: shared-logs
      emptyDir: {}

  containers:
    - name: nginx-container
      image: nginx:latest
      volumeMounts:
        - name: shared-logs
          mountPath: /var/log/nginx

    - name: sidecar-container
      image: ubuntu:latest
      command: ["sh", "-c", "while true; do cat /var/log/nginx/access.log /var/log/nginx/error.log; sleep 30; done"]
      volumeMounts:
        - name: shared-logs
          mountPath: /var/log/nginx
```

---

### üöÄ Apply the Pod

Run the following on the **jump_host**:

```bash
kubectl apply -f webserver.yaml
```

---

### üîç Verify

```bash
kubectl get pod webserver
kubectl logs webserver -c sidecar-container
```

---

### üß† How this works (quick recap)

* **nginx-container** ‚Üí writes access & error logs to `/var/log/nginx`
* **sidecar-container** ‚Üí reads and ships logs every 30 seconds
* **emptyDir** ‚Üí shared temporary storage scoped to the Pod
* **Sidecar pattern** ‚Üí clean separation of concerns ‚úîÔ∏è

This command:

```bash
cat /var/log/nginx/access.log /var/log/nginx/error.log
```

### üìå What it does (simple explanation)

* `cat` means **concatenate / display file contents**.
* It **prints the contents** of:

  * `access.log` ‚Üí records **incoming HTTP requests**
  * `error.log` ‚Üí records **nginx errors and warnings**

Both files are located in:

```
/var/log/nginx/
```

---

### üß† In your sidecar container context

* These log files are written by the **nginx container**.
* They are accessible in the **sidecar container** because:

  * Both containers share the same `emptyDir` volume
  * Mounted at `/var/log/nginx`

So the sidecar can **read logs generated by nginx in real time**.

---

### üîç Example output

```text
127.0.0.1 - - [16/Jan/2026:14:32:01 +0000] "GET / HTTP/1.1" 200 612
2026/01/16 14:32:05 [error] 6#6: *1 open() "/usr/share/nginx/html/test" failed (2: No such file or directory)
```

---

### ‚ö†Ô∏è Important note

* `cat` **prints the whole file each time**.
* In real production setups, tools like:

  * `tail -f`
  * `fluent-bit`
  * `filebeat`
    are used instead to **stream logs efficiently**.

---

### ‚úÖ One-line summary

üëâ This command **displays nginx access and error logs so the sidecar container can read and forward them**.

If you want, I can explain the difference between `cat` and `tail -f` in this use case.


If you want, I can also show how to convert this into a **Deployment** or integrate a **real log shipper (Fluent Bit / Filebeat)** later.
